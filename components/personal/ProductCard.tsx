"use client";

import { useEffect, useMemo, useState } from "react";
import { getVaultSummary, type VaultSummary, getAssetAddress, ERC20_MIN_ABI, ajeyVault } from "@/lib/services/vault";
import { usePrivy, useWallets } from "@privy-io/react-auth";
import { createWalletClient, custom, encodeFunctionData, parseUnits, toHex, BaseError, ContractFunctionRevertedError, formatEther } from "viem";
import { baseSepolia } from "viem/chains";
import { AjeyVaultAbi } from "@/abi/AjeyVault";
 

export default function ProductCard() {
  const [data, setData] = useState<VaultSummary | null>(null);
  const [open, setOpen] = useState(false);
  const [amount, setAmount] = useState<string>(""); // deposit amount (ETH)
  const [withdrawAmount, setWithdrawAmount] = useState<string>(""); // withdraw amount (ETH)
  const [submitting, setSubmitting] = useState(false);
  const [withdrawing, setWithdrawing] = useState(false);
  const { user } = usePrivy();
  const { wallets } = useWallets();
  const [maxWithdrawEth, setMaxWithdrawEth] = useState<string | null>(null);

  const evmProvider = useMemo(() => {
    // Privy embeds wallets; in browser we can access window.ethereum
    if (typeof window !== "undefined" && (window as any).ethereum) {
      return (window as any).ethereum;
    }
    return null;
  }, []);

  useEffect(() => {
    let t: any;
    let stopped = false;
    const load = async () => {
      try {
        const d = await getVaultSummary();
        if (!stopped) setData(d);
      } catch {
        if (!stopped) setData(null);
      } finally {
        // reduce refetch churn; update periodically
        t = setTimeout(load, 20000);
      }
    };
    load();
    return () => { stopped = true; clearTimeout(t); };
  }, []);

  // Load max withdraw for connected user to guide withdrawals
  useEffect(() => {
    let cancelled = false;
    async function loadMax() {
      try {
        const primaryWallet = wallets && wallets.length > 0 ? wallets[0] : undefined;
        const account = (primaryWallet?.address as `0x${string}`) || ((user as any)?.wallet?.address as `0x${string}` | undefined);
        if (!account || !ajeyVault) { setMaxWithdrawEth(null); return; }
        const { publicClient } = await import("@/lib/chain");
        const v = await publicClient.readContract({ ...(ajeyVault as any), functionName: "maxWithdraw", args: [account] }) as bigint;
        if (!cancelled) setMaxWithdrawEth(formatEther(v));
      } catch {
        if (!cancelled) setMaxWithdrawEth(null);
      }
    }
    loadMax();
    return () => { cancelled = true; };
  }, [wallets, user]);

  return (
    <div className="rounded-xl border p-6 bg-background/60 backdrop-blur">
      <div className="flex items-center justify-between">
        <h2 className="text-xl font-semibold">Ajey Vault</h2>
        <button
          className="text-sm px-3 py-1 rounded-md border"
          onClick={() => setOpen((v) => !v)}
        >
          {open ? "Hide" : "Details"}
        </button>
      </div>
      <div className="mt-3 grid grid-cols-4 gap-4 text-sm">
        <div>
          <div className="text-muted-foreground">Total Assets</div>
          <div>{data?.totalAssetsFormatted ? `${data.totalAssetsFormatted} ETH` : (data?.totalAssetsWei ? `${data.totalAssetsWei} wei` : "—")}</div>
        </div>
        <div>
          <div className="text-muted-foreground">NAV / Share</div>
          <div>{data?.navPerShare ?? "—"}</div>
        </div>
        <div>
          <div className="text-muted-foreground">vToken Supply</div>
          <div>{data?.vTokenSupply ?? "—"}</div>
        </div>
        <div>
          <div className="text-muted-foreground">Est. Yield</div>
          <div>{data?.aprRangeText || estimateYieldText(data)}</div>
        </div>
      </div>

      {open && (
        <div className="mt-4">
          <p className="text-sm text-muted-foreground">
            Yield is generated by supplying idle assets to Aave v3. Vault shares track value via ERC‑4626 exchange rate.
          </p>
          <div className="mt-3 grid md:grid-cols-3 gap-3">
            {data?.strategies?.map((s) => (
              <div key={s.id} className="rounded-lg border p-3">
                <div className="text-sm font-medium">{s.name}</div>
                <div className="text-xs text-muted-foreground">{s.allocationPct}% allocated</div>
                <div className="text-xs">APR {s.aprPct}%</div>
              </div>
            ))}
          </div>
          <div className="mt-3 text-xs text-muted-foreground">
            {data?.paused ? "Vault paused" : "Vault active"}{data?.ethMode ? " · ETH deposits enabled" : ""}
          </div>
          {maxWithdrawEth && (
            <div className="mt-2 text-xs">
              <span className="text-muted-foreground">Max Withdraw: </span>
              <span>{maxWithdrawEth} ETH</span>
            </div>
          )}
        </div>
      )}

      <div className="mt-4 grid grid-cols-1 md:grid-cols-2 gap-3 items-start">
        <div className="text-xs text-muted-foreground space-y-2">
          <div>Deposit adds to the vault. Withdraw sends native ETH back to your wallet.</div>
          <div className="opacity-80">Tip: Use Max to auto-fill.</div>
        </div>
        <div className="flex items-center gap-2 justify-end flex-wrap">
        <input
          type="number"
          value={amount}
          onChange={(e) => setAmount(e.target.value)}
          placeholder="Deposit (ETH)"
          className="w-40 rounded-md border bg-background px-3 py-2 text-sm"
        />
        <button
          type="button"
          onClick={async () => {
            try {
              const primaryWallet = wallets && wallets.length > 0 ? wallets[0] : undefined;
              const provider = primaryWallet ? await primaryWallet.getEthereumProvider() : (evmProvider as any);
              if (!provider) return;
              const bal = await (provider as any).request?.({ method: "eth_getBalance", params: [primaryWallet?.address, "latest"] });
              if (!bal) return;
              const wei = BigInt(bal);
              // Keep small gas reserve (~0.0002 ETH)
              const reserve = BigInt(2e14);
              const usable = wei > reserve ? wei - reserve : BigInt(0);
              setAmount(formatEther(usable));
            } catch {}
          }}
          className="rounded-md border px-2 py-2 text-xs"
        >Max</button>
        <button
          disabled={!amount || submitting || !!data?.paused}
          onClick={async () => {
            if (!ajeyVault) return alert("Vault not configured");
            try {
              setSubmitting(true);
              const primaryWallet = wallets && wallets.length > 0 ? wallets[0] : undefined;
              const account = (primaryWallet?.address as `0x${string}`) || ((user as any)?.wallet?.address as `0x${string}` | undefined);
              if (!account) throw new Error("No connected address");

              // debug log
              fetch("/api/debug/log", { method: "POST", headers: { "content-type": "application/json" }, body: JSON.stringify({ scope: "deposit", step: "start", data: { account } }) });

              // Ensure wallet is on Base Sepolia using Privy wallet API where possible
              try {
                if (primaryWallet?.switchChain) {
                  await primaryWallet.switchChain(baseSepolia.id);
                }
              } catch {
                fetch("/api/debug/log", { method: "POST", headers: { "content-type": "application/json" }, body: JSON.stringify({ scope: "deposit", step: "switchChain_failed" }) });
                throw new Error("Please switch your wallet network to Base Sepolia");
              }

              // Resolve asset and decimals for proper units
              const asset = await getAssetAddress();
              const decimals = (await publicNavigatorReadDecimals(asset)) || 18;
              const assets = parseUnits(amount, decimals);
              fetch("/api/debug/log", { method: "POST", headers: { "content-type": "application/json" }, body: JSON.stringify({ scope: "deposit", step: "resolved_amount", data: { asset, decimals, assets: assets.toString() } }) });

              // Build viem wallet client from embedded wallet provider
              const provider = primaryWallet ? await primaryWallet.getEthereumProvider() : (evmProvider as any);
              const client = createWalletClient({ chain: baseSepolia, transport: custom(provider) });

              // Log current chain id from provider
              try {
                const cid = await (provider as any)?.request?.({ method: "eth_chainId" });
                fetch("/api/debug/log", { method: "POST", headers: { "content-type": "application/json" }, body: JSON.stringify({ scope: "deposit", step: "pre_tx_chain", data: { chainId: String(cid) } }) });
              } catch {}

              // Try ETH path first: depositEth(receiver) with value
              let usedEthPath = false;
              try {
                const { publicClient } = await import("@/lib/chain");
                const sim = await publicClient.simulateContract({
                  ...(ajeyVault as any),
                  functionName: "depositEth",
                  args: [account],
                  value: assets,
                  account,
                } as any);
                const req: any = sim.request;
                fetch("/api/debug/log", { method: "POST", headers: { "content-type": "application/json" }, body: JSON.stringify({ scope: "deposit", step: "simulate_depositEth_ok", data: { gas: req.gas?.toString?.(), maxFeePerGas: req.maxFeePerGas?.toString?.(), maxPriorityFeePerGas: req.maxPriorityFeePerGas?.toString?.(), value: req.value?.toString?.() } }) });
                const hash = await client.writeContract(req);
                fetch("/api/debug/log", { method: "POST", headers: { "content-type": "application/json" }, body: JSON.stringify({ scope: "deposit", step: "tx_submitted_eth", data: { hash } }) });
                alert(`Deposit submitted: ${hash}`);
                usedEthPath = true;
              } catch (err: any) {
                let reason: string | undefined;
                if (err instanceof BaseError) {
                  const r = err.walk((e) => e instanceof ContractFunctionRevertedError) as ContractFunctionRevertedError | undefined;
                  reason = r?.data?.errorName;
                }
                fetch("/api/debug/log", { method: "POST", headers: { "content-type": "application/json" }, body: JSON.stringify({ scope: "deposit", step: "simulate_depositEth_failed", data: { reason: reason || err?.message } }) });
                usedEthPath = false;
              }

              if (!usedEthPath) {
                // ERC20 path: if asset is WETH, wrap native ETH first, then approve + deposit(assets, receiver)
                const { publicClient } = await import("@/lib/chain");
                const WETH_BASE_CANONICAL = "0x4200000000000000000000000000000000000006";

                if ((asset as string).toLowerCase() === WETH_BASE_CANONICAL.toLowerCase()) {
                  try {
                    const simWrap = await publicClient.simulateContract({
                      address: asset,
                      abi: [ { name: "deposit", type: "function", stateMutability: "payable", inputs: [], outputs: [] } ] as any,
                      functionName: "deposit",
                      args: [],
                      value: assets,
                      account,
                    } as any);
                    const reqWrap: any = simWrap.request;
                    fetch("/api/debug/log", { method: "POST", headers: { "content-type": "application/json" }, body: JSON.stringify({ scope: "deposit", step: "simulate_wrap_ok", data: { gas: reqWrap.gas?.toString?.(), value: reqWrap.value?.toString?.() } }) });
                    const hashWrap = await client.writeContract(reqWrap);
                    fetch("/api/debug/log", { method: "POST", headers: { "content-type": "application/json" }, body: JSON.stringify({ scope: "deposit", step: "wrap_submitted", data: { hash: hashWrap } }) });
                  } catch (err: any) {
                    fetch("/api/debug/log", { method: "POST", headers: { "content-type": "application/json" }, body: JSON.stringify({ scope: "deposit", step: "wrap_failed", data: { message: err?.message } }) });
                    throw new Error("WETH wrap failed; please ensure ETH balance and try again.");
                  }
                }
                const allowance: bigint = await publicNavigatorReadAllowance(asset, account, ajeyVault.address);
                if (allowance < assets) {
                  const simApprove = await publicClient.simulateContract({
                    address: asset,
                    abi: ERC20_MIN_ABI as any,
                    functionName: "approve",
                    args: [ajeyVault.address, assets],
                    account,
                  } as any);
                  const reqApprove: any = simApprove.request;
                  fetch("/api/debug/log", { method: "POST", headers: { "content-type": "application/json" }, body: JSON.stringify({ scope: "deposit", step: "simulate_approve_ok", data: { gas: reqApprove.gas?.toString?.(), maxFeePerGas: reqApprove.maxFeePerGas?.toString?.(), maxPriorityFeePerGas: reqApprove.maxPriorityFeePerGas?.toString?.() } }) });
                  const hashApprove = await client.writeContract(reqApprove);
                  fetch("/api/debug/log", { method: "POST", headers: { "content-type": "application/json" }, body: JSON.stringify({ scope: "deposit", step: "approve_submitted" }) });
                }

                const simDeposit = await publicClient.simulateContract({
                  ...(ajeyVault as any),
                  functionName: "deposit",
                  args: [assets, account],
                  account,
                } as any);
                const reqDep: any = simDeposit.request;
                fetch("/api/debug/log", { method: "POST", headers: { "content-type": "application/json" }, body: JSON.stringify({ scope: "deposit", step: "simulate_deposit_ok", data: { gas: reqDep.gas?.toString?.(), maxFeePerGas: reqDep.maxFeePerGas?.toString?.(), maxPriorityFeePerGas: reqDep.maxPriorityFeePerGas?.toString?.() } }) });
                let hash: string;
                try {
                  hash = await client.writeContract(reqDep);
                } catch (err: any) {
                  let reason: string | undefined;
                  if (err instanceof BaseError) {
                    const r = err.walk((e) => e instanceof ContractFunctionRevertedError) as ContractFunctionRevertedError | undefined;
                    reason = r?.data?.errorName;
                  }
                  fetch("/api/debug/log", { method: "POST", headers: { "content-type": "application/json" }, body: JSON.stringify({ scope: "deposit", step: "deposit_write_failed", data: { reason: reason || err?.message } }) });
                  throw err;
                }
                fetch("/api/debug/log", { method: "POST", headers: { "content-type": "application/json" }, body: JSON.stringify({ scope: "deposit", step: "tx_submitted_erc20", data: { hash } }) });
                alert(`Deposit submitted: ${hash}`);
              }
              setAmount("");
            } catch (e: any) {
              fetch("/api/debug/log", { method: "POST", headers: { "content-type": "application/json" }, body: JSON.stringify({ scope: "deposit", step: "error", data: { message: e?.message || String(e) } }) });
              alert(e?.message || String(e));
            } finally {
              fetch("/api/debug/log", { method: "POST", headers: { "content-type": "application/json" }, body: JSON.stringify({ scope: "deposit", step: "end" }) });
              setSubmitting(false);
            }
          }}
          className="rounded-md border px-4 py-2 text-sm"
        >
          {data?.paused ? "Paused" : submitting ? "Submitting..." : "Deposit"}
        </button>
        <input
          type="number"
          value={withdrawAmount}
          onChange={(e) => setWithdrawAmount(e.target.value)}
          placeholder="Withdraw (ETH)"
          className="w-40 rounded-md border bg-background px-3 py-2 text-sm"
        />
        <button
          type="button"
          onClick={() => { if (maxWithdrawEth) setWithdrawAmount(maxWithdrawEth); }}
          className="rounded-md border px-2 py-2 text-xs"
        >Max</button>
        <button
          disabled={!withdrawAmount || withdrawing || !!data?.paused}
          onClick={async () => {
            if (!ajeyVault) return alert("Vault not configured");
            try {
              setWithdrawing(true);
              const primaryWallet = wallets && wallets.length > 0 ? wallets[0] : undefined;
              const account = (primaryWallet?.address as `0x${string}`) || ((user as any)?.wallet?.address as `0x${string}` | undefined);
              if (!account) throw new Error("No connected address");

              // debug log
              fetch("/api/debug/log", { method: "POST", headers: { "content-type": "application/json" }, body: JSON.stringify({ scope: "withdraw", step: "start", data: { account } }) });

              // Ensure wallet is on Base Sepolia
              try {
                if (primaryWallet?.switchChain) {
                  await primaryWallet.switchChain(baseSepolia.id);
                }
              } catch {
                fetch("/api/debug/log", { method: "POST", headers: { "content-type": "application/json" }, body: JSON.stringify({ scope: "withdraw", step: "switchChain_failed" }) });
                throw new Error("Please switch your wallet network to Base Sepolia");
              }

              // Resolve asset and decimals and parse amount
              const asset = await getAssetAddress();
              const decimals = (await publicNavigatorReadDecimals(asset)) || 18;
              const assets = parseUnits(withdrawAmount, decimals);
              fetch("/api/debug/log", { method: "POST", headers: { "content-type": "application/json" }, body: JSON.stringify({ scope: "withdraw", step: "resolved_amount", data: { asset, decimals, assets: assets.toString() } }) });

              // Build viem wallet client from embedded wallet provider
              const provider = primaryWallet ? await primaryWallet.getEthereumProvider() : (evmProvider as any);
              const client = createWalletClient({ chain: baseSepolia, transport: custom(provider) });

              // Log current chain id from provider
              try {
                const cid = await (provider as any)?.request?.({ method: "eth_chainId" });
                fetch("/api/debug/log", { method: "POST", headers: { "content-type": "application/json" }, body: JSON.stringify({ scope: "withdraw", step: "pre_tx_chain", data: { chainId: String(cid) } }) });
              } catch {}

              // Read guards & limits: paused, ethMode, maxWithdraw
              const { publicClient } = await import("@/lib/chain");
              const [paused, ethMode, maxW] = await Promise.all([
                publicClient.readContract({ ...(ajeyVault as any), functionName: "paused" }) as Promise<boolean>,
                publicClient.readContract({ ...(ajeyVault as any), functionName: "ethMode" }) as Promise<boolean>,
                publicClient.readContract({ ...(ajeyVault as any), functionName: "maxWithdraw", args: [account] }) as Promise<bigint>,
              ]);
              fetch("/api/debug/log", { method: "POST", headers: { "content-type": "application/json" }, body: JSON.stringify({ scope: "withdraw", step: "guards", data: { paused, ethMode, maxWithdraw: maxW.toString() } }) });
              if (paused) throw new Error("Vault is paused");
              if (!ethMode) throw new Error("ETH withdrawals are disabled");
              if (assets > maxW) throw new Error("Amount exceeds max withdraw");

              // Preview required shares
              const shares = await publicClient.readContract({ ...(ajeyVault as any), functionName: "previewWithdraw", args: [assets] }) as bigint;
              fetch("/api/debug/log", { method: "POST", headers: { "content-type": "application/json" }, body: JSON.stringify({ scope: "withdraw", step: "preview_withdraw_ok", data: { shares: shares.toString() } }) });

              // Simulate withdrawEth then write
              try {
                const sim = await publicClient.simulateContract({
                  ...(ajeyVault as any),
                  functionName: "withdrawEth",
                  args: [assets, account, account],
                  account,
                } as any);
                const req: any = sim.request;
                fetch("/api/debug/log", { method: "POST", headers: { "content-type": "application/json" }, body: JSON.stringify({ scope: "withdraw", step: "simulate_withdrawEth_ok", data: { gas: req.gas?.toString?.(), maxFeePerGas: req.maxFeePerGas?.toString?.(), maxPriorityFeePerGas: req.maxPriorityFeePerGas?.toString?.() } }) });
                const hash = await client.writeContract(req);
                fetch("/api/debug/log", { method: "POST", headers: { "content-type": "application/json" }, body: JSON.stringify({ scope: "withdraw", step: "tx_submitted_withdrawEth", data: { hash } }) });
                alert(`Withdrawal submitted: ${hash}`);
              } catch (err: any) {
                let reason: string | undefined;
                if (err instanceof BaseError) {
                  const r = err.walk((e) => e instanceof ContractFunctionRevertedError) as ContractFunctionRevertedError | undefined;
                  reason = r?.data?.errorName;
                }
                fetch("/api/debug/log", { method: "POST", headers: { "content-type": "application/json" }, body: JSON.stringify({ scope: "withdraw", step: "withdraw_write_failed", data: { reason: reason || err?.message } }) });
                throw err;
              }

              setWithdrawAmount("");
            } catch (e: any) {
              fetch("/api/debug/log", { method: "POST", headers: { "content-type": "application/json" }, body: JSON.stringify({ scope: "withdraw", step: "error", data: { message: e?.message || String(e) } }) });
              alert(e?.message || String(e));
            } finally {
              fetch("/api/debug/log", { method: "POST", headers: { "content-type": "application/json" }, body: JSON.stringify({ scope: "withdraw", step: "end" }) });
              setWithdrawing(false);
            }
          }}
          className="rounded-md border px-4 py-2 text-sm"
        >
          {data?.paused ? "Paused" : withdrawing ? "Withdrawing..." : "Withdraw"}
        </button>
        </div>
      </div>

      {/* Agent reasoning trace — light subtle panel */}
      <AgentTracePanel />
    </div>
  );
}

async function publicNavigatorReadDecimals(token: `0x${string}`): Promise<number | undefined> {
  try {
    // Lazy import to keep module graph lean
    const { publicClient } = await import("@/lib/chain");
    const dec = (await publicClient.readContract({ address: token, abi: ERC20_MIN_ABI, functionName: "decimals" })) as number;
    return dec;
  } catch {
    return undefined;
  }
}

async function publicNavigatorReadAllowance(token: `0x${string}`, owner: `0x${string}`, spender: `0x${string}`): Promise<bigint> {
  try {
    const { publicClient } = await import("@/lib/chain");
    return (await publicClient.readContract({ address: token, abi: ERC20_MIN_ABI, functionName: "allowance", args: [owner, spender] })) as bigint;
  } catch {
    return BigInt(0);
  }
}


function estimateYieldText(data: VaultSummary | null) {
  if (!data) return "—";
  // Simple placeholder: derive pseudo-APR from navPerShare delta vs 1.0
  const nav = Number(data.navPerShare || 0);
  if (!isFinite(nav) || nav <= 0) return "—";
  const apr = Math.max(0, (nav - 1) * 100).toFixed(2);
  return `${apr}%`;
}

  function AgentTracePanel() {
    const [queue, setQueue] = useState<Array<{ id: string; text: string }>>([]);
    const [show, setShow] = useState<{ id: string; text: string } | null>(null);
    useEffect(() => {
      let poll: any;
      let cycle: any;
      let stopped = false;
      async function fetchOnce() {
        try {
          const res = await fetch("/api/activity", { cache: "no-store" });
          const data = await res.json();
          const candidates = (data?.items || [])
            .filter((x: any) => x?.type === "allocate" && (x?.details))
            .slice(0, 5)
            .map((x: any) => ({ id: x.id, text: x.details as string }));
          if (!stopped) setQueue(candidates);
        } catch {}
      }
      // light polling every 20s
      fetchOnce();
      poll = setInterval(fetchOnce, 20000);
      // ephemeral display: rotate every 4s
      const rotate = () => {
        setShow((prev) => {
          const currentIdx = prev ? queue.findIndex((q) => q.id === prev.id) : -1;
          const next = queue[(currentIdx + 1 + queue.length) % (queue.length || 1)];
          return next || null;
        });
      };
      cycle = setInterval(() => {
        if (queue.length > 0) rotate();
      }, 4000);
      return () => { stopped = true; clearInterval(poll); clearInterval(cycle); };
    }, [queue.length]);

    if (!show) return null;
    return (
      <div className="mt-6 rounded-md border bg-white/50 dark:bg-white/5 p-3 overflow-hidden">
        <div className="text-xs font-medium text-muted-foreground mb-2">Agent reasoning</div>
        <div className="text-xs animate-[slideIn_300ms_ease]">
          {show.text}
        </div>
        <style>{`@keyframes slideIn{from{transform:translateY(6px);opacity:.0}to{transform:translateY(0);opacity:1}}`}</style>
      </div>
    );
  }


