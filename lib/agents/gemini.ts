// Server-only Gemini wrapper using the official SDK (@google/genai)
// Docs (JS quickstart): https://ai.google.dev/gemini-api/docs/quickstart

import { GoogleGenAI, Type } from "@google/genai";
import { sendNativeTransfer } from "@/lib/agents/wallet";

export type GeminiPlanRequest = {
  kind: "deposit" | "pod_proposal";
  payload: Record<string, unknown>;
};

export type GeminiPlanResponse = {
  rationale: string;
  plan: Record<string, unknown>;
  toolCalls?: Array<{ name: string; args: Record<string, unknown>; result?: unknown }>;
  trace?: string[];
  usage?: { thoughtsTokenCount?: number; candidatesTokenCount?: number };
};

// Models by role
const WORKFLOW_MODEL = process.env.GEMINI_MODEL || "gemini-2.5-flash";
const REASONING_MODEL = process.env.GEMINI_REASONING_MODEL || "gemini-2.5-pro";

function getClient() {
  if (typeof window !== "undefined") throw new Error("Gemini must run server-side");
  // The SDK automatically reads GEMINI_API_KEY from env per docs
  return new GoogleGenAI({});
}

function getToolDeclarations() {
  return [
    {
      functionDeclarations: [
        {
          name: "signAndSendNative",
          description:
            "Signs and sends a native ETH transfer on Base Sepolia using a designated agent wallet.",
          parameters: {
            type: "object",
            properties: {
              to: { type: "string", description: "Recipient EVM address" },
              amountEth: { type: "string", description: "Amount in ETH as a decimal string" },
              role: {
                type: "string",
                description: "Agent role to use (default, deposit, pod)",
              },
              dryRun: {
                type: "boolean",
                description: "If true, do not actually broadcast",
              },
            },
            required: ["to", "amountEth"],
          },
        },
      ],
    },
  ];
}

function extractToolCalls(resp: any) {
  const calls: Array<{ name: string; args: Record<string, unknown> }> = [];
  const parts = resp?.candidates?.[0]?.content?.parts || [];
  for (const p of parts) {
    if (p?.functionCall?.name) {
      calls.push({ name: p.functionCall.name, args: p.functionCall.args || {} });
    }
  }
  return calls;
}

export async function generatePlan(
  request: GeminiPlanRequest,
  options?: { model?: string; allowOnchain?: boolean },
): Promise<GeminiPlanResponse> {
  const ai = getClient();

  const system =
    "You are a workflow planner and executor for DeFi vault operations. " +
    "Prefer making explicit, minimal plans. Use available tools only when parameters are clear.";

  const user =
    `Task: ${request.kind}.\n` +
    `Input: ${JSON.stringify(request.payload)}\n` +
    "Return a short 'rationale'. If tool use is appropriate, call the function with exact arguments.";

  const model = options?.model || WORKFLOW_MODEL;
  const prompt = `${system}\n\n${user}`;
  const config: any = { temperature: 0.2 };
  if (model.includes("flash")) {
    config.thinkingConfig = { thinkingBudget: 0 };
  }

  const params: any = {
    model,
    contents: prompt,
    config,
  };
  params.tools = getToolDeclarations();

  const response: any = await ai.models.generateContent(params);

  const rationale: string = response?.text || "Generated by Gemini";
  const toolCalls = extractToolCalls(response);

  const results: Array<{ name: string; args: any; result?: unknown }> = [];
  const canExecute = options?.allowOnchain && process.env.AGENT_ALLOW_ONCHAIN === "true";

  for (const call of toolCalls) {
    if (call.name === "signAndSendNative") {
      const { to, amountEth, role, dryRun } = call.args as any;
      if (canExecute && !dryRun) {
        const res = await sendNativeTransfer({
          to,
          amountEth: String(amountEth),
          role: (role as any) || "default",
        });
        results.push({ name: call.name, args: call.args, result: res });
      } else {
        results.push({ name: call.name, args: call.args, result: { dryRun: true } });
      }
    }
  }

  return {
    rationale,
    plan: { action: request.kind, input: request.payload, results },
    toolCalls: toolCalls.map((c) => ({ name: c.name, args: c.args })),
  };
}

// Reasoning-agent specific entrypoint using the pro model by default
export async function generateReasoningPlan(
  request: GeminiPlanRequest,
  options?: { model?: string; allowOnchain?: boolean },
): Promise<GeminiPlanResponse> {
  const ai = getClient();

  const system =
    "You are a portfolio allocation reasoning agent. Given vault idle funds and a list of preapproved Aave v3 pools on Base Sepolia with current yields, " +
    "select the single best pool by current yield and prepare a minimal allocation instruction for the workflow agent.";

  const user =
    `Task: ${request.kind}.\n` +
    `Input: ${JSON.stringify(request.payload)}\n` +
    "Return JSON only with fields: rationale, plan { action, amountAssets, poolAddress, poolName }.";

  const model = options?.model || REASONING_MODEL;
  const prompt = `${system}\n\n${user}`;
  const config: any = {
    temperature: 0,
    responseMimeType: "application/json",
    responseSchema: {
      type: Type.OBJECT,
      properties: {
        rationale: { type: Type.STRING },
        plan: {
          type: Type.OBJECT,
          properties: {
            action: { type: Type.STRING },
            amountAssets: { type: Type.STRING },
            poolAddress: { type: Type.STRING },
            poolName: { type: Type.STRING },
          },
          propertyOrdering: ["action", "amountAssets", "poolAddress", "poolName"],
          required: ["action", "amountAssets", "poolAddress"],
        },
      },
      propertyOrdering: ["rationale", "plan"],
    },
  };
  if (model.includes("flash")) {
    config.thinkingConfig = { thinkingBudget: 0 };
  }

  const params: any = {
    model,
    contents: prompt,
    config,
  };
  params.tools = getToolDeclarations();

  const response: any = await ai.models.generateContent(params);
  // JS SDK: structured output available as JSON string in response.text per docs
  // https://ai.google.dev/gemini-api/docs/structured-output
  const raw = (response?.text as string) || "{}";
  let parsed: any = {};
  try {
    parsed = JSON.parse(raw);
  } catch {
    parsed = {};
  }
  const rationale: string = parsed?.rationale || "";

  // Capture thinking traces when available (Gemini 2.5)
  const parts = response?.candidates?.[0]?.content?.parts || [];
  const trace: string[] = [];
  for (const p of parts) {
    if (p?.thought && typeof p.text === "string") trace.push(p.text);
  }
  const usage = {
    thoughtsTokenCount: response?.usageMetadata?.thoughtsTokenCount,
    candidatesTokenCount: response?.usageMetadata?.candidatesTokenCount,
  };

  const toolCalls = extractToolCalls(response);
  const results: Array<{ name: string; args: any; result?: unknown }> = [];
  const canExecute = options?.allowOnchain && process.env.AGENT_ALLOW_ONCHAIN === "true";
  for (const call of toolCalls) {
    if (call.name === "signAndSendNative") {
      const { to, amountEth, role, dryRun } = call.args as any;
      if (canExecute && !dryRun) {
        const res = await sendNativeTransfer({
          to,
          amountEth: String(amountEth),
          role: (role as any) || "default",
        });
        results.push({ name: call.name, args: call.args, result: res });
      } else {
        results.push({ name: call.name, args: call.args, result: { dryRun: true } });
      }
    }
  }

  // Return the model's structured object as `plan` to downstream consumers
  const planObj = parsed && typeof parsed === "object" ? parsed : {};
  return {
    rationale,
    plan: planObj,
    toolCalls: toolCalls.map((c) => ({ name: c.name, args: c.args })),
    trace,
    usage,
  };
}


