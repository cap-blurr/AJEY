// Server-only Gemini wrapper using the official SDK (@google/genai)
// Docs (JS quickstart): https://ai.google.dev/gemini-api/docs/quickstart

import { GoogleGenAI } from "@google/genai";
import { sendNativeTransfer } from "@/lib/agents/wallet";

export type GeminiPlanRequest = {
  kind: "deposit" | "pod_proposal";
  payload: Record<string, unknown>;
};

export type GeminiPlanResponse = {
  rationale: string;
  plan: Record<string, unknown>;
  toolCalls?: Array<{ name: string; args: Record<string, unknown>; result?: unknown }>;
};

// Models by role
const WORKFLOW_MODEL = process.env.GEMINI_MODEL || "gemini-2.5-flash";
const REASONING_MODEL = process.env.GEMINI_REASONING_MODEL || "gemini-2.5-pro";

function getClient() {
  if (typeof window !== "undefined") throw new Error("Gemini must run server-side");
  // The SDK automatically reads GEMINI_API_KEY from env per docs
  return new GoogleGenAI({});
}

function getToolDeclarations() {
  return [
    {
      functionDeclarations: [
        {
          name: "signAndSendNative",
          description:
            "Signs and sends a native ETH transfer on Base Sepolia using a designated agent wallet.",
          parameters: {
            type: "object",
            properties: {
              to: { type: "string", description: "Recipient EVM address" },
              amountEth: { type: "string", description: "Amount in ETH as a decimal string" },
              role: {
                type: "string",
                description: "Agent role to use (default, deposit, pod)",
              },
              dryRun: {
                type: "boolean",
                description: "If true, do not actually broadcast",
              },
            },
            required: ["to", "amountEth"],
          },
        },
      ],
    },
  ];
}

function extractToolCalls(resp: any) {
  const calls: Array<{ name: string; args: Record<string, unknown> }> = [];
  const parts = resp?.candidates?.[0]?.content?.parts || [];
  for (const p of parts) {
    if (p?.functionCall?.name) {
      calls.push({ name: p.functionCall.name, args: p.functionCall.args || {} });
    }
  }
  return calls;
}

export async function generatePlan(
  request: GeminiPlanRequest,
  options?: { model?: string; allowOnchain?: boolean },
): Promise<GeminiPlanResponse> {
  const ai = getClient();

  const system =
    "You are a workflow planner and executor for DeFi vault operations. " +
    "Prefer making explicit, minimal plans. Use available tools only when parameters are clear.";

  const user =
    `Task: ${request.kind}.\n` +
    `Input: ${JSON.stringify(request.payload)}\n` +
    "Return a short 'rationale'. If tool use is appropriate, call the function with exact arguments.";

  const model = options?.model || WORKFLOW_MODEL;
  const prompt = `${system}\n\n${user}`;
  const config: any = { temperature: 0.2 };
  if (model.includes("flash")) {
    config.thinkingConfig = { thinkingBudget: 0 };
  }

  const params: any = {
    model,
    contents: prompt,
    config,
  };
  params.tools = getToolDeclarations();

  const response: any = await ai.models.generateContent(params);

  const rationale: string = response?.text || "Generated by Gemini";
  const toolCalls = extractToolCalls(response);

  const results: Array<{ name: string; args: any; result?: unknown }> = [];
  const canExecute = options?.allowOnchain && process.env.AGENT_ALLOW_ONCHAIN === "true";

  for (const call of toolCalls) {
    if (call.name === "signAndSendNative") {
      const { to, amountEth, role, dryRun } = call.args as any;
      if (canExecute && !dryRun) {
        const res = await sendNativeTransfer({
          to,
          amountEth: String(amountEth),
          role: (role as any) || "default",
        });
        results.push({ name: call.name, args: call.args, result: res });
      } else {
        results.push({ name: call.name, args: call.args, result: { dryRun: true } });
      }
    }
  }

  return {
    rationale,
    plan: { action: request.kind, input: request.payload, results },
    toolCalls: toolCalls.map((c) => ({ name: c.name, args: c.args })),
  };
}

// Reasoning-agent specific entrypoint using the pro model by default
export async function generateReasoningPlan(
  request: GeminiPlanRequest,
  options?: { model?: string; allowOnchain?: boolean },
): Promise<GeminiPlanResponse> {
  const ai = getClient();

  const system =
    "You are a portfolio allocation reasoning agent. " +
    "Incorporate data feed context and produce a clear allocation plan. Use tools only when parameters are explicit.";

  const user =
    `Task: ${request.kind}.\n` +
    `Input: ${JSON.stringify(request.payload)}\n` +
    "Return a short 'rationale'. If tool use is appropriate, call the function with exact arguments.";

  const model = options?.model || REASONING_MODEL;
  const prompt = `${system}\n\n${user}`;
  const config: any = { temperature: 0 };
  if (model.includes("flash")) {
    config.thinkingConfig = { thinkingBudget: 0 };
  }

  const params: any = {
    model,
    contents: prompt,
    config,
  };
  params.tools = getToolDeclarations();

  const response: any = await ai.models.generateContent(params);
  const rationale: string = response?.text || "Generated by Gemini";
  const toolCalls = extractToolCalls(response);

  const results: Array<{ name: string; args: any; result?: unknown }> = [];
  const canExecute = options?.allowOnchain && process.env.AGENT_ALLOW_ONCHAIN === "true";
  for (const call of toolCalls) {
    if (call.name === "signAndSendNative") {
      const { to, amountEth, role, dryRun } = call.args as any;
      if (canExecute && !dryRun) {
        const res = await sendNativeTransfer({
          to,
          amountEth: String(amountEth),
          role: (role as any) || "default",
        });
        results.push({ name: call.name, args: call.args, result: res });
      } else {
        results.push({ name: call.name, args: call.args, result: { dryRun: true } });
      }
    }
  }

  return {
    rationale,
    plan: { action: request.kind, input: request.payload, results },
    toolCalls: toolCalls.map((c) => ({ name: c.name, args: c.args })),
  };
}


