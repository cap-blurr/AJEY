// Server-only OpenAI wrapper using the official SDK (openai)
// Docs:
// - Quickstart: https://platform.openai.com/docs/quickstart
// - Structured outputs: https://platform.openai.com/docs/guides/structured-outputs
// - Function calling: https://platform.openai.com/docs/guides/function-calling
// - Reasoning & summaries: https://platform.openai.com/docs/guides/reasoning?lang=javascript

import OpenAI from "openai";
import { executeAllocation } from "@/lib/agents/workflow";

export type OpenAIPlanRequest = {
  kind: "deposit" | "pod_proposal";
  payload: Record<string, unknown>;
};

export type OpenAIPlanResponse = {
  rationale: string;
  plan: Record<string, unknown>;
  thoughts?: string[];
  usage?: { thoughtsTokenCount?: number; candidatesTokenCount?: number };
};

// Models by role
const WORKFLOW_MODEL = process.env.GPT_MODEL || "gpt-5-mini-2025-08-07";
const REASONING_MODEL = process.env.GPT_REASONING_MODEL || "gpt-5-2025-08-07";

function getClient() {
  if (typeof window !== "undefined") throw new Error("OpenAI must run server-side");
  // Use OPENAI_KEY explicitly (the SDK defaults to OPENAI_API_KEY otherwise)
  const apiKey = (process.env.OPENAI_KEY || "").trim();
  if (!apiKey) throw new Error("OPENAI_KEY not set");
  return new OpenAI({ apiKey });
}

// Tool calling and direct on-chain actions are disabled for the reasoning agent.

export async function generatePlan(
  request: OpenAIPlanRequest,
  options?: { model?: string; allowOnchain?: boolean },
): Promise<OpenAIPlanResponse> {
  const ai = getClient();

  const system =
    "You are a workflow planner and executor for DeFi vault operations. " +
    "Prefer making explicit, minimal plans. Use available tools only when parameters are clear.";

  const user =
    `Task: ${request.kind}.\n` +
    `Input: ${JSON.stringify(request.payload)}\n` +
    "Return a short 'rationale'. If tool use is appropriate, call the function with exact arguments.";

  const model = options?.model || WORKFLOW_MODEL;

  const tools: any[] = [
    {
      type: "function",
      function: {
        name: "allocateToVault",
        description:
          "Allocates WETH from the Ajey Vault to Aave by calling supplyToAave(amountWei).",
        parameters: {
          type: "object",
          properties: {
            amountWei: {
              type: "string",
              description: "Amount in wei to supply (stringified bigint)",
            },
            dryRun: {
              type: "boolean",
              description: "If true, don't broadcast on-chain",
            },
          },
          required: ["amountWei"],
          additionalProperties: false,
        },
      },
    },
  ];

  const input = [
    { role: "system", content: [{ type: "text", text: system }] },
    { role: "user", content: [{ type: "text", text: user }] },
  ];

  const response = await (ai as any).responses.create({
    model,
    input,
    tools,
    tool_choice: "auto",
  });

  const rationale: string = (response?.output_text as string) || "Generated by OpenAI";

  // Extract potential function calls from Responses API output
  const calls: Array<{ name: string; args: Record<string, unknown> }> = [];
  try {
    const output = (response as any)?.output || [];
    for (const item of output) {
      // Tool call item
      if (item?.type === "tool_call" && item?.tool_name) {
        let args: any = {};
        try { args = item?.arguments ? JSON.parse(item.arguments) : {}; } catch { args = {}; }
        calls.push({ name: item.tool_name, args });
      }
      // Messages may also contain tool calls depending on provider behavior
      if (item?.type === "message" && Array.isArray(item?.content)) {
        for (const c of item.content) {
          if (c?.type === "tool_use" && c?.name) {
            let args: any = {};
            try { args = c?.input ? (typeof c.input === "string" ? JSON.parse(c.input) : c.input) : {}; } catch { args = {}; }
            calls.push({ name: c.name, args });
          }
        }
      }
    }
  } catch {}

  const results: Array<{ name: string; args: any; result?: unknown }> = [];
  const canExecute = options?.allowOnchain && process.env.AGENT_ALLOW_ONCHAIN === "true";
  for (const call of calls) {
    if (call.name === "allocateToVault") {
      const { amountWei, dryRun } = call.args as any;
      if (canExecute && !dryRun) {
        const res = await executeAllocation({ amountWei: String(amountWei) });
        results.push({ name: call.name, args: call.args, result: res });
      } else {
        results.push({ name: call.name, args: call.args, result: { dryRun: true } });
      }
    }
  }

  const usage = {
    thoughtsTokenCount: undefined as number | undefined,
    candidatesTokenCount: (response as any)?.usage?.output_tokens as number | undefined,
  };

  return {
    rationale,
    plan: { action: request.kind, input: request.payload, results },
    thoughts: [],
    usage,
  };
}

// Reasoning-agent specific entrypoint using the reasoning model by default
export async function generateReasoningPlan(
  request: OpenAIPlanRequest,
  options?: { model?: string; allowOnchain?: boolean },
): Promise<OpenAIPlanResponse> {
  const ai = getClient();

  // Build a strict JSON-only envelope with explicit instructions and inputs
  const model = options?.model || REASONING_MODEL;

  const instructionsPreset = {
    version: 1,
    objective:
      "Propose a single target allocation plan for WETH supply-only (no borrowing) on Base Sepolia.",
    policy: {
      filter: { requireActive: true, requireNotFrozen: true, minAvailableUSD: "0" },
      rank: ["supplyAprPercent desc", "availableUSD desc", "tvlUSD desc"],
      constraints: [
        "Only consider supplyAprPercent; ignore borrow-related metrics.",
        "Require availableUSD > 0 and capacity headroom if capped.",
        "Proposed amountWei must be <= vault.idleWei and within supply cap headroom.",
        "Vault asset is WETH; pool selection is fixed and does not require an address.",
        "Use ETH increments >= 0.0001 ETH. Round down to the nearest 0.0001 ETH when converting to wei.",
      ],
    },
    outputSpec: {
      rankingFields: [
        "asset",
        "symbol",
        "supplyAprPercent",
        "availableUSD",
        "tvlUSD",
        "capacityHeadroomUSD",
      ],
      planFields: ["action", "amountWei", "thinkingSummary"],
    },
  };

  const envelope = {
    instructions: instructionsPreset,
    inputs: request.payload,
  };

  const prompt = JSON.stringify(envelope);

  // JSON Schema for strict structured output
  const schema: any = {
    type: "object",
    properties: {
      rationale: { type: "string" },
      thinkingSummary: { type: "string" },
      ranking: {
        type: "array",
        items: {
          type: "object",
          properties: {
            asset: { type: "string" },
            symbol: { type: "string" },
            supplyAprPercent: { type: "number" },
            availableUSD: { type: "string" },
            tvlUSD: { type: "string" },
            capacityHeadroomUSD: { type: "string" },
          },
          required: [
            "asset",
            "symbol",
            "supplyAprPercent",
            "availableUSD",
            "tvlUSD",
            "capacityHeadroomUSD",
          ],
          additionalProperties: false,
        },
      },
      plan: {
        type: "object",
        properties: {
          action: { type: "string" },
          amountWei: { type: "string" },
          thinkingSummary: { type: "string" },
        },
        required: ["action", "amountWei", "thinkingSummary"],
        additionalProperties: false,
      },
    },
    required: ["rationale", "thinkingSummary", "ranking", "plan"],
    additionalProperties: false,
  };

  const reasoningParam = model.toLowerCase().startsWith("gpt-5") ? { reasoning: { effort: "high" as const } } : {};

  const response = await (ai as any).responses.create({
    model,
    input: prompt,
    text: {
      format: {
        type: "json_schema",
        name: "AjeyReasoningPlan",
        schema,
        strict: true,
      },
    },
    ...reasoningParam,
  });

  const raw: string = (response?.output_text as string) || "{}";
  let parsed: any = {};
  try {
    parsed = JSON.parse(raw);
  } catch {
    parsed = {};
  }

  const rationale: string = parsed?.rationale || "";
  const summaryFromSchema: string | undefined = parsed?.thinkingSummary || parsed?.plan?.thinkingSummary;
  const thoughts: string[] = [];
  if (typeof summaryFromSchema === "string" && summaryFromSchema.length > 0) thoughts.push(summaryFromSchema);

  const usage = {
    thoughtsTokenCount: (response?.usage?.output_tokens_details?.reasoning_tokens as number | undefined) || undefined,
    candidatesTokenCount: (response?.usage?.output_tokens as number | undefined) || undefined,
  } as { thoughtsTokenCount?: number; candidatesTokenCount?: number };

  const planObj = parsed && typeof parsed === "object" ? parsed : {};
  return {
    rationale,
    plan: planObj,
    thoughts,
    usage,
  };
}


